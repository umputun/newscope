/*!include:re2c "base.re" */

// PYTHON NAME: COPYRIGHT_PATTERN
// Given year: 199[0-9]|20[0-3][0-9]
// Original pattern: (?:©|\&copy;|Copyright|\(c\))\D*(?:year)?-?(year)\D
func CopyrightPattern(input string) [][]int {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	var allIndexes [][]int
	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		year = 199[0-9]|20[0-3][0-9];
		quant1    = (!©|[&]copy[;]|Copyright|[(]c[)])[^0-9]*;
		copyright = (!©|[&]copy[;]|Copyright|[(]c[)])[^0-9]*(!{year})?-?({year})[^0-9];

		{copyright} {
			allIndexes = append(allIndexes, copyIndexes(yypmatch))
			continue
		}

		{quant1} { continue }
		*        { continue }
		$        { return allIndexes }
		*/
	}
}

// PYTHON NAME: THREE_PATTERN
// Original pattern: /([0-9]{4}/[0-9]{2}/[0-9]{2})[01/]
func ThreePattern(input string) [][]int {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	var allIndexes [][]int
	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		three = [/]([0-9]{4}[/][0-9]{2}[/][0-9]{2})[01/];

		{three} {
			allIndexes = append(allIndexes, copyIndexes(yypmatch))
			continue
		}

		* { continue }
		$ { return allIndexes }
		*/
	}
}

// PYTHON NAME: THREE_LOOSE_PATTERN
// Original pattern: \D([0-9]{4}[/.-][0-9]{2}[/.-][0-9]{2})\D
func ThreeLoosePattern(input string) [][]int {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	var allIndexes [][]int
	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		threeLoose = [^0-9]([0-9]{4}[/.-][0-9]{2}[/.-][0-9]{2})[^0-9];

		{threeLoose} {
			allIndexes = append(allIndexes, copyIndexes(yypmatch))
			continue
		}

		* { continue }
		$ { return allIndexes }
		*/
	}
}

// PYTHON NAME: DATESTRINGS_PATTERN
// Original pattern: (\D19[0-9]{2}[01][0-9][0-3][0-9]\D|\D20[0-9]{2}[01][0-9][0-3][0-9]\D)
func DateStringsPattern(input string) [][]int {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	var allIndexes [][]int
	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		dateStrings = ([^0-9]19[0-9]{2}[01][0-9][0-3][0-9][^0-9]|[^0-9]20[0-9]{2}[01][0-9][0-3][0-9][^0-9]);

		{dateStrings} {
			allIndexes = append(allIndexes, copyIndexes(yypmatch))
			continue
		}

		* { continue }
		$ { return allIndexes }
		*/
	}
}

// PYTHON NAME: YYYYMM_PATTERN
// Original pattern: \D([12][0-9]{3}[/.-](?:1[0-2]|0[1-9]))\D
func YyyyMmPattern(input string) [][]int {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	var allIndexes [][]int
	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		yyyyMm = [^0-9]([12][0-9]{3}[/.-](!1[0-2]|0[1-9]))[^0-9];

		{yyyyMm} {
			allIndexes = append(allIndexes, copyIndexes(yypmatch))
			continue
		}

		* { continue }
		$ { return allIndexes }
		*/
	}
}

// PYTHON NAME: SIMPLE_PATTERN
// Given year: 199[0-9]|20[0-3][0-9]
// Original pattern: \D(year)\D
func SimplePattern(input string) [][]int {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	var allIndexes [][]int
	for { /*!use:re2c:base_template
		re2c:posix-captures = 1;

		year = 199[0-9]|20[0-3][0-9];
		simple = [^0-9]({year})[^0-9];

		{simple} {
			allIndexes = append(allIndexes, copyIndexes(yypmatch))
			continue
		}

		* { continue }
		$ { return allIndexes }
		*/
	}
}