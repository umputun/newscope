/*!include:re2c "base.re" */

// Original pattern: (?i)(next|weiter|continue|>([^\|]|$)|»([^\|]|$))
func IsNextPaginationLink(input string) bool {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	for { /*!use:re2c:base_template
		re2c:posix-captures   = 1;
		re2c:case-insensitive = 1;

		nextLink1 = next|weiter|continue;
		nextLink2 = [>»][^|];
		nextLink3 = [>»];					// Handle [>»]$

		{nextLink1} { return true }
		{nextLink2} { return true }
		{nextLink3} {
			// Handle [>»]$
			if yypmatch[1] == limit {
				return true
			} else {
				continue
			}
		}

		* { continue }
		$ { return false }
		*/
	}
}

// Original pattern: (?i)(prev|early|old|new|<|«)
func IsPrevPaginationLink(input string) bool {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	for { /*!use:re2c:base_template
		re2c:case-insensitive = 1;

		prevLink = prev|early|old|new|«|[<];

		{prevLink} { return true }
		*          { continue }
		$          { return false }
		*/
	}
}

// Original pattern: (?i)article|body|content|entry|hentry|main|page|pagination|post|text|blog|story
func IsPositiveToBePagination(input string) bool {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	for { /*!use:re2c:base_template
		re2c:case-insensitive = 1;

		positive = article|body|content|entry|hentry|main|page|pagination|post|text|blog|story;

		{positive} { return true }
		*          { continue }
		$          { return false }
		*/
	}
}

// Original pattern: (?i)combx|comment|com-|contact|foot|footer|footnote|masthead|media|meta|outbrain|promo|related|shoutbox|sidebar|sponsor|shopping|tags|tool|widget
func IsNegativeToBePagination(input string) bool {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	for { /*!use:re2c:base_template
		re2c:case-insensitive = 1;

		negative = combx|comment|com-|contact|foot|footer|footnote|masthead|media|meta|outbrain|promo|related|shoutbox|sidebar|sponsor|shopping|tags|tool|widget;

		{negative} { return true }
		*          { continue }
		$          { return false }
		*/
	}
}

// Original pattern: (?i)print|archive|comment|discuss|e[\-]?mail|share|reply|all|login|sign|single|as one|article|post|篇
func IsExtraneousToPagination(input string) bool {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	for { /*!use:re2c:base_template
		re2c:case-insensitive = 1;

		extraneous = print|archive|comment|discuss|e[\-]?mail|share|reply|all|login|sign|single|as[ ]one|article|post|篇;

		{extraneous} { return true }
		*            { continue }
		$            { return false }
		*/
	}
}

// Original pattern: (?i)pag(e|ing|inat)
func IsMightBePagination(input string) bool {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	for { /*!use:re2c:base_template
		re2c:case-insensitive = 1;

		mightBe = pag(!e|ing|inat);

		{mightBe} { return true }
		*         { continue }
		$         { return false }
		*/
	}
}

// Original pattern: (?i)p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1,2}$
func IsMightBeLinkPagination(input string) bool {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	// Variable for capturing parentheses (twice the number of groups).
	/*!maxnmatch:re2c*/
	yypmatch := make([]int, YYMAXNMATCH*2)
	var yynmatch int
	_ = yynmatch

	// Autogenerated tag variables used by the lexer to track tag values.
	/*!stags:re2c format = 'var @@ int; _ = @@\n'; */

	for { /*!use:re2c:base_template
		re2c:posix-captures   = 1;
		re2c:case-insensitive = 1;

		p(!a|g|ag)?(!e|ing|ination)?[=/][0-9]{1,2} {
			if yypmatch[1] == limit {
				return true
			} else {
				continue
			}
		}

		*         { continue }
		$         { return false }
		*/
	}
}

// Original pattern: (?i)(first|last)
func ContainsFirstLast(input string) bool {
	var cursor, marker int
	input += string(rune(0)) // add terminating null
	limit := len(input) - 1  // limit points at the terminating null
	_ = marker

	for { /*!use:re2c:base_template
		re2c:case-insensitive = 1;

		first|last { return true }
		*          { continue }
		$          { return false }
		*/
	}
}
