<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Как я делал бота для борьбы со спамом в Telegram</title>
    <meta name="description" content="История создания tg-spam - бота для автоматической борьбы со спамом в Telegram каналах">
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <header class="site-header">
        <nav class="main-nav">
            <a href="/" class="logo">Умпутун</a>
            <ul class="nav-links">
                <li><a href="/archive">Архив</a></li>
                <li><a href="/about">О блоге</a></li>
                <li><a href="/projects">Проекты</a></li>
                <li><a href="/rss">RSS</a></li>
            </ul>
        </nav>
    </header>

    <main class="content">
        <article class="post">
            <header class="post-header">
                <h1 class="post-title">Как я делал бота для борьбы со спамом в Telegram</h1>
                <div class="post-meta">
                    <time datetime="2024-03-05">5 марта 2024</time>
                    <span class="reading-time">15 мин чтения</span>
                </div>
            </header>

            <div class="post-content">
                <p>В последнее время в Telegram стало много спама, и, вероятно, все, кто управляет относительно большими каналами, сталкивались с этой проблемой. Строго говоря, спам заметен уже при 500 подписчиках, но когда их число достигает 5000+, это становится просто невыносимым. Я долгое время игнорировал эту проблему и был активно против традиционных методов борьбы со спамом, таких как капчи, подтверждения и прочие предварительные фильтры. С моей точки зрения, лучше пропустить спам, чем потерять или обидеть реального пользователя. Это работало несколько лет, и все, что приходилось делать, это изредка банить. Но вот когда спама стало слишком много для ручного отстрела, я решил что-то предпринять.</p>

                <h2>Первые шаги</h2>

                <p>Очевидно, что конечный продукт должен быть ботом, который будет как-то понимать, что есть спам, и предпринимать меры. Сразу возникла идея (ее подсказал bobuk) использовать простую эвристику и считать тех, кто постит много эмодзи, спамерами. Этот шаблон в то время был вполне подходящим, так как спамеры часто использовали ненормальное количество эмодзи в своих сообщениях. Так что я написал простого бота, который считал эмодзи в сообщении и банил тех, кто их использовал слишком много.</p>

                <p>Конечно, этот подход лучше, чем ничего, но он далеко не идеален и, совершенно точно, принесет только временное облегчение. Но сама идея использования простых правил была неплоха, так что я решил продолжить в том же духе. Мы заметили, что спамеры часто призывают "Зайти в личку" или "Подписаться на канал", так что я организовал список запрещенных слов и фраз и банил тех, кто их использовал.</p>

                <h3>Попытка добавить чужие правила</h3>

                <p>Следующий шаг был добавить поддержку стороннего сервиса, который собирает спамеров и предоставляет их список. Я нашел <a href="https://cas.chat/">CAS</a>, который при помощи простого HTTP запроса отвечает на вопрос "Этот пользователь спамер?". Добавить поддержку этого сервиса было делом нескольких минут, и я был уверен, что это улучшит ситуацию. Но, к сожалению, это не принесло никаких видимых результатов. Моя цель - забанить спамера, как только он появляется, но в CAS они, видимо, появляются слишком поздно. Скорее всего, они собирают информацию о спамере после того, как он уже успел нагадить. В результате, я решил, что CAS стоит оставить, но не особо на него полагаться. Забегая вперед, скажу, что после того, как рабочая версия бота была запущена, проверка CAS отлавливала не более 10% спамеров, и не было ни одного случая, когда только проверка CAS сработала, и никакая другая эвристика или классификатор не смогли бы определить спамера.</p>

                <p><em>UPD: сегодня (8 марта 2024) это произошло, первый раз CAS проверка выловила спам который упустили другие правила.</em></p>

                <h3>Попытка добавить немного AI</h3>

                <p>Идея скормить текст в OpenAI (когда я это начинал, был в основном доступен GPT-3.5) и попросить определить, насколько оно похоже на спам, показалась многообещающей. Технически в этом нет ничего сложного - придумать prompt и отправить его в API вместе с текстом сообщения. С горем пополам удалось заставить его отвечать структурированно, но результаты были не очень. Во-первых, это стоило денег, небольших, но тем не менее. Во-вторых, точность была не очень, процент ложных срабатываний был недопустимо высок. В-третьих, это было медленно. Я отказался от этой идеи, хотя вернулся к ней позже, когда GPT-4 стал доступен. У него результаты были намного лучше, почти идеальные. Если бы не зависимость от стороннего сервиса и его цена, я бы просто использовал его и не заморачивался бы с прочими методами.</p>

                <h3>Подход с обнаружением сообщений похожих на ранее виденный спам</h3>

                <p>Эта идея мне показалась перспективной. Скормить несколько сотен примеров спама (для начала), токенизировать его, попутно очищая от шума и коротких/общих слов, и посчитать cosine similarity каждого примера с сообщением, которое мы хотим проверить. Если сходство больше, чем некий порог, то сообщение считается спамом. Это было бы быстро, дешево и, как мне казалось, эффективно. И опять, результат был не особо обнадеживающим. Да, отловленные им похожие на спам сообщения практически всегда были спамом, но когда начали появляться новые спамеры, которые писали совсем (или даже немного) по-другому, этот метод перестал работать. В результате, от этого метода я не отказался, но он стал одним из многих, и далеко не самым эффективным.</p>

                <h3>То, с чего надо было начать - классификатор с дообучением</h3>

                <p>Мысль, что для подобной классификации spam/ham отлично подойдет Naive Bayes, пришла мне не сразу. Но когда она пришла, я понял, что это то, с чего надо было начать. Алгоритм простой и относительно быстрый, скармливаем примеры спама и не-спама и просим сказать, на что больше похоже. Когда появляется новый вид спама, который мы до этого не видели - добавляем его в выборку и переобучаем классификатор. Если происходит ложное срабатывание, добавляем сообщение в выборку ham (то, что не спам). Этот подход работал лучше всего, и я пожалел, что не начал с него. Строго говоря, одного этого классификатора было бы достаточно для 95% всех случаев, с которыми мне приходилось сталкиваться, но убрать все остальные методы рука не поднималась.</p>

                <h3>Последний штрих - обнаружение спамеров по сообщениям с недостаточной информацией</h3>

                <p>Это в основном про грубый и прямой спам, где куча ссылок, но мало (или совсем нет) текста. Также сообщения без текста, но с картинками. Для таких случаев я добавил пару эвристик, которые срабатывают на подобные сообщения, например, если ссылок больше, чем слов в сообщении, то это спам. Это простой способ, который опционален, не требует обучения и работает быстро. Я его так и не включил, т.к. на практике он не был пока нужен, но он там есть на тот случай, если понадобится.</p>

                <p><em>UPD: 23 марта 2024 обратил внимание, что появился настоящий спам с картинками и без текста. Включение обнаружителя "сообщения без текста, но с картинками", которое я откладывал до последнего, опасаясь ложных срабатываний, за пару недель работы показало себя очень достойно.</em></p>

                <h2>Аспекты реализации</h2>

                <p>Все это я реализовал на Go, упаковал в Docker-контейнер и запустил на своем сервере. Основной классификатор предполагает, что администраторы могут добавлять сообщения в выборку и переобучать классификатор, так что пришлось интегрировать все это непосредственно в бота. Я старался сделать управление максимально простым: чтобы добавить сообщение в спам, достаточно либо переслать его в отдельный канал для администраторов, либо просто ответить на него командой <code>/spam</code>. Затем все происходит автоматически: сообщение удаляется, отправитель блокируется, и сообщение добавляется в выборку для переобучения.</p>

                <p>Если сообщение было определено как спам, оно автоматически отправляется в канал администраторов, где показывается, почему оно было так классифицировано со всеми доступными деталями. В случае ложного срабатывания администратор может одним нажатием кнопки отменить блокировку, добавить сообщение в выборку ham и переобучить классификатор.</p>

                <figure>
                    <figcaption>Пример управления спамом из Телеграмма</figcaption>
                    <img src="/images/posts/tg-spam/tg-spam-group.png" alt="Скриншот управления спамом">
                </figure>

                <p>Еще один аспект это оптимизация скорости. Не вижу смысла проверять каждое сообщение пользователя на спам, если он уже отправил 10 сообщений, и все они были классифицированы как не спам. Такие пользователи добавляются в белый список, и их сообщения больше не проверяются. На практике оказалось, что даже 10 сообщений — это слишком много, так как спамеры, отправляющие сначала несколько нейтральных сообщений, а затем спам, встречаются крайне редко.</p>

                <p>Чтобы снизить потенциальные затраты на проверку через OpenAI, я сделал ее последним этапом, после всех остальных проверок. Эта проверка может быть как решающей (если все остальные методы пропустили спам), так и подтверждающей (если спам уже был обнаружен другим способом), и в любом случае она вызывается нечасто. Повторюсь, что пока не возникало необходимости активировать эту проверку, но она готова к использованию.</p>

                <p>Когда я начал использовать <code>tg-spam</code> и у него появились активные пользователи кроме меня, выяснилось, что базовой функциональности иногда не хватает. В результате, появился режим обучения, когда бот не удаляет сообщения, а лишь маркирует их как спам/не спам, позволяя админам самостоятельно решить, что с ними делать. Также появилась функция добавления пользователей в белый список и их удаления оттуда. Еще я ввел "параноидальный режим", в котором все сообщения проверяются на спам.</p>

                <p>Исходная версия не сохраняла состояние (кроме недавно обученных данных spam/ham), и любая информация, например список проверенных пользователей, терялась при перезагрузке. Хотя это не было реальной проблемой, на практике возникла необходимость в сохранении состояния. Теперь он хранит все данные в SQLite, и при перезапуске все восстанавливается.</p>

                <p><em>Замечу, что написание функциональной части бота было довольно простым, но с реализацией его интерактивной части я намучился. Это был мой первый и, надеюсь, последний опыт работы со всеми этими элементами управления, которые требуют плясок с бубном, чтобы самые простые вещи заработали и, совершенно точно, придуманы какими-то вредителями, чтобы максимально усложнить жизнь разработчикам.</em></p>

                <h2>WEB интерфейс</h2>

                <p>Для удобства администраторов я добавил веб-интерфейс, где можно найти все сообщения, которые были определены как спам, и посмотреть, почему. Там же можно добавить сообщение в выборку spam/ham и переобучить классификатор. Также там можно протестировать сообщение на спам и посмотреть, насколько уверен классификатор в своем решении и какие проверки сработали.</p>

                <figure>
                    <figcaption>Примеры web интерфейса</figcaption>
                    <img src="/images/posts/tg-spam/admin-detected-spam.png" alt="Интерфейс обнаруженного спама">
                    <img src="/images/posts/tg-spam/admin-manage-samples.png" alt="Интерфейс управления образцами">
                </figure>

                <h2>Результаты</h2>

                <p>Это все я назвал <a href="https://tg-spam.umputun.dev/">tg-spam</a>, и эта штука реально работает, и работает очень достойно. Главная проблема таких систем — это ложные срабатывания, но их у меня было совсем немного. Конечно, иногда спам не определялся, но это была редкость, когда появлялся совсем новый вид спама. Админы на это реагировали быстро, добавляли его в выборку, и после этого все подобные сообщения определялись как спам.</p>

                <p>Кроме готового к использованию бота, который настраивается за 5 минут, я подготовил и библиотеку для Go, которая позволяет использовать все эти методы в своем коде, например для определения спама в системах, не связанных с Telegram. Еще у сервиса есть простой HTTP API, и его можно использовать для проверки сообщений на спам, и для добавления сообщений в выборку для переобучения.</p>

                <h2>Где это взять</h2>

                <p>Это open source проект и его можно найти на <a href="https://github.com/umputun/tg-spam">umputun/tg-spam</a>. Можно взять как собранный образ, так и бинарный файл. Код доступен под лицензией MIT, и я буду рад если <code>tg-spam</code> кому-то пригодится.</p>
            </div>

            <footer class="post-footer">
                <div class="tags">
                    <span class="tag">telegram</span>
                    <span class="tag">golang</span>
                    <span class="tag">anti-spam</span>
                    <span class="tag">machine-learning</span>
                </div>

                <div class="share-buttons">
                    <a href="#" class="share-twitter">Twitter</a>
                    <a href="#" class="share-facebook">Facebook</a>
                    <a href="#" class="share-telegram">Telegram</a>
                </div>
            </footer>
        </article>

        <!-- Comments section -->
        <section class="comments">
            <h3>Комментарии</h3>
            <div class="comment-form">
                <textarea placeholder="Оставить комментарий..."></textarea>
                <button>Отправить</button>
            </div>
            <div class="comment-list">
                <div class="comment">
                    <span class="author">user123</span>
                    <span class="date">6 марта 2024</span>
                    <p>Отличная статья! Спасибо за подробное описание.</p>
                </div>
            </div>
        </section>
    </main>

    <aside class="sidebar">
        <div class="widget">
            <h3>Популярные посты</h3>
            <ul>
                <li><a href="#">Как я делал свой подкаст</a></li>
                <li><a href="#">Миграция с Docker на Podman</a></li>
                <li><a href="#">Опыт использования Go в продакшене</a></li>
            </ul>
        </div>

        <div class="widget">
            <h3>Теги</h3>
            <div class="tag-cloud">
                <a href="#" class="tag">golang</a>
                <a href="#" class="tag">docker</a>
                <a href="#" class="tag">linux</a>
                <a href="#" class="tag">programming</a>
            </div>
        </div>
    </aside>

    <footer class="site-footer">
        <p>&copy; 2024 Умпутун. Все права защищены.</p>
        <nav>
            <a href="/privacy">Приватность</a>
            <a href="/contact">Контакты</a>
        </nav>
    </footer>
</body>
</html>