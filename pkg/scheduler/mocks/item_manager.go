// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"

	"github.com/umputun/newscope/pkg/domain"
)

// ItemManagerMock is a mock implementation of scheduler.ItemManager.
//
//	func TestSomethingThatUsesItemManager(t *testing.T) {
//
//		// make and configure a mocked scheduler.ItemManager
//		mockedItemManager := &ItemManagerMock{
//			CreateItemFunc: func(ctx context.Context, item *domain.Item) error {
//				panic("mock out the CreateItem method")
//			},
//			GetItemFunc: func(ctx context.Context, id int64) (*domain.Item, error) {
//				panic("mock out the GetItem method")
//			},
//			ItemExistsFunc: func(ctx context.Context, feedID int64, guid string) (bool, error) {
//				panic("mock out the ItemExists method")
//			},
//			ItemExistsByTitleOrURLFunc: func(ctx context.Context, title string, url string) (bool, error) {
//				panic("mock out the ItemExistsByTitleOrURL method")
//			},
//			UpdateItemExtractionFunc: func(ctx context.Context, itemID int64, extraction *domain.ExtractedContent) error {
//				panic("mock out the UpdateItemExtraction method")
//			},
//			UpdateItemProcessedFunc: func(ctx context.Context, itemID int64, extraction *domain.ExtractedContent, classification *domain.Classification) error {
//				panic("mock out the UpdateItemProcessed method")
//			},
//		}
//
//		// use mockedItemManager in code that requires scheduler.ItemManager
//		// and then make assertions.
//
//	}
type ItemManagerMock struct {
	// CreateItemFunc mocks the CreateItem method.
	CreateItemFunc func(ctx context.Context, item *domain.Item) error

	// GetItemFunc mocks the GetItem method.
	GetItemFunc func(ctx context.Context, id int64) (*domain.Item, error)

	// ItemExistsFunc mocks the ItemExists method.
	ItemExistsFunc func(ctx context.Context, feedID int64, guid string) (bool, error)

	// ItemExistsByTitleOrURLFunc mocks the ItemExistsByTitleOrURL method.
	ItemExistsByTitleOrURLFunc func(ctx context.Context, title string, url string) (bool, error)

	// UpdateItemExtractionFunc mocks the UpdateItemExtraction method.
	UpdateItemExtractionFunc func(ctx context.Context, itemID int64, extraction *domain.ExtractedContent) error

	// UpdateItemProcessedFunc mocks the UpdateItemProcessed method.
	UpdateItemProcessedFunc func(ctx context.Context, itemID int64, extraction *domain.ExtractedContent, classification *domain.Classification) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateItem holds details about calls to the CreateItem method.
		CreateItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Item is the item argument value.
			Item *domain.Item
		}
		// GetItem holds details about calls to the GetItem method.
		GetItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// ItemExists holds details about calls to the ItemExists method.
		ItemExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FeedID is the feedID argument value.
			FeedID int64
			// GUID is the guid argument value.
			GUID string
		}
		// ItemExistsByTitleOrURL holds details about calls to the ItemExistsByTitleOrURL method.
		ItemExistsByTitleOrURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Title is the title argument value.
			Title string
			// URL is the url argument value.
			URL string
		}
		// UpdateItemExtraction holds details about calls to the UpdateItemExtraction method.
		UpdateItemExtraction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ItemID is the itemID argument value.
			ItemID int64
			// Extraction is the extraction argument value.
			Extraction *domain.ExtractedContent
		}
		// UpdateItemProcessed holds details about calls to the UpdateItemProcessed method.
		UpdateItemProcessed []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ItemID is the itemID argument value.
			ItemID int64
			// Extraction is the extraction argument value.
			Extraction *domain.ExtractedContent
			// Classification is the classification argument value.
			Classification *domain.Classification
		}
	}
	lockCreateItem             sync.RWMutex
	lockGetItem                sync.RWMutex
	lockItemExists             sync.RWMutex
	lockItemExistsByTitleOrURL sync.RWMutex
	lockUpdateItemExtraction   sync.RWMutex
	lockUpdateItemProcessed    sync.RWMutex
}

// CreateItem calls CreateItemFunc.
func (mock *ItemManagerMock) CreateItem(ctx context.Context, item *domain.Item) error {
	if mock.CreateItemFunc == nil {
		panic("ItemManagerMock.CreateItemFunc: method is nil but ItemManager.CreateItem was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Item *domain.Item
	}{
		Ctx:  ctx,
		Item: item,
	}
	mock.lockCreateItem.Lock()
	mock.calls.CreateItem = append(mock.calls.CreateItem, callInfo)
	mock.lockCreateItem.Unlock()
	return mock.CreateItemFunc(ctx, item)
}

// CreateItemCalls gets all the calls that were made to CreateItem.
// Check the length with:
//
//	len(mockedItemManager.CreateItemCalls())
func (mock *ItemManagerMock) CreateItemCalls() []struct {
	Ctx  context.Context
	Item *domain.Item
} {
	var calls []struct {
		Ctx  context.Context
		Item *domain.Item
	}
	mock.lockCreateItem.RLock()
	calls = mock.calls.CreateItem
	mock.lockCreateItem.RUnlock()
	return calls
}

// GetItem calls GetItemFunc.
func (mock *ItemManagerMock) GetItem(ctx context.Context, id int64) (*domain.Item, error) {
	if mock.GetItemFunc == nil {
		panic("ItemManagerMock.GetItemFunc: method is nil but ItemManager.GetItem was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetItem.Lock()
	mock.calls.GetItem = append(mock.calls.GetItem, callInfo)
	mock.lockGetItem.Unlock()
	return mock.GetItemFunc(ctx, id)
}

// GetItemCalls gets all the calls that were made to GetItem.
// Check the length with:
//
//	len(mockedItemManager.GetItemCalls())
func (mock *ItemManagerMock) GetItemCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockGetItem.RLock()
	calls = mock.calls.GetItem
	mock.lockGetItem.RUnlock()
	return calls
}

// ItemExists calls ItemExistsFunc.
func (mock *ItemManagerMock) ItemExists(ctx context.Context, feedID int64, guid string) (bool, error) {
	if mock.ItemExistsFunc == nil {
		panic("ItemManagerMock.ItemExistsFunc: method is nil but ItemManager.ItemExists was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		FeedID int64
		GUID   string
	}{
		Ctx:    ctx,
		FeedID: feedID,
		GUID:   guid,
	}
	mock.lockItemExists.Lock()
	mock.calls.ItemExists = append(mock.calls.ItemExists, callInfo)
	mock.lockItemExists.Unlock()
	return mock.ItemExistsFunc(ctx, feedID, guid)
}

// ItemExistsCalls gets all the calls that were made to ItemExists.
// Check the length with:
//
//	len(mockedItemManager.ItemExistsCalls())
func (mock *ItemManagerMock) ItemExistsCalls() []struct {
	Ctx    context.Context
	FeedID int64
	GUID   string
} {
	var calls []struct {
		Ctx    context.Context
		FeedID int64
		GUID   string
	}
	mock.lockItemExists.RLock()
	calls = mock.calls.ItemExists
	mock.lockItemExists.RUnlock()
	return calls
}

// ItemExistsByTitleOrURL calls ItemExistsByTitleOrURLFunc.
func (mock *ItemManagerMock) ItemExistsByTitleOrURL(ctx context.Context, title string, url string) (bool, error) {
	if mock.ItemExistsByTitleOrURLFunc == nil {
		panic("ItemManagerMock.ItemExistsByTitleOrURLFunc: method is nil but ItemManager.ItemExistsByTitleOrURL was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Title string
		URL   string
	}{
		Ctx:   ctx,
		Title: title,
		URL:   url,
	}
	mock.lockItemExistsByTitleOrURL.Lock()
	mock.calls.ItemExistsByTitleOrURL = append(mock.calls.ItemExistsByTitleOrURL, callInfo)
	mock.lockItemExistsByTitleOrURL.Unlock()
	return mock.ItemExistsByTitleOrURLFunc(ctx, title, url)
}

// ItemExistsByTitleOrURLCalls gets all the calls that were made to ItemExistsByTitleOrURL.
// Check the length with:
//
//	len(mockedItemManager.ItemExistsByTitleOrURLCalls())
func (mock *ItemManagerMock) ItemExistsByTitleOrURLCalls() []struct {
	Ctx   context.Context
	Title string
	URL   string
} {
	var calls []struct {
		Ctx   context.Context
		Title string
		URL   string
	}
	mock.lockItemExistsByTitleOrURL.RLock()
	calls = mock.calls.ItemExistsByTitleOrURL
	mock.lockItemExistsByTitleOrURL.RUnlock()
	return calls
}

// UpdateItemExtraction calls UpdateItemExtractionFunc.
func (mock *ItemManagerMock) UpdateItemExtraction(ctx context.Context, itemID int64, extraction *domain.ExtractedContent) error {
	if mock.UpdateItemExtractionFunc == nil {
		panic("ItemManagerMock.UpdateItemExtractionFunc: method is nil but ItemManager.UpdateItemExtraction was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ItemID     int64
		Extraction *domain.ExtractedContent
	}{
		Ctx:        ctx,
		ItemID:     itemID,
		Extraction: extraction,
	}
	mock.lockUpdateItemExtraction.Lock()
	mock.calls.UpdateItemExtraction = append(mock.calls.UpdateItemExtraction, callInfo)
	mock.lockUpdateItemExtraction.Unlock()
	return mock.UpdateItemExtractionFunc(ctx, itemID, extraction)
}

// UpdateItemExtractionCalls gets all the calls that were made to UpdateItemExtraction.
// Check the length with:
//
//	len(mockedItemManager.UpdateItemExtractionCalls())
func (mock *ItemManagerMock) UpdateItemExtractionCalls() []struct {
	Ctx        context.Context
	ItemID     int64
	Extraction *domain.ExtractedContent
} {
	var calls []struct {
		Ctx        context.Context
		ItemID     int64
		Extraction *domain.ExtractedContent
	}
	mock.lockUpdateItemExtraction.RLock()
	calls = mock.calls.UpdateItemExtraction
	mock.lockUpdateItemExtraction.RUnlock()
	return calls
}

// UpdateItemProcessed calls UpdateItemProcessedFunc.
func (mock *ItemManagerMock) UpdateItemProcessed(ctx context.Context, itemID int64, extraction *domain.ExtractedContent, classification *domain.Classification) error {
	if mock.UpdateItemProcessedFunc == nil {
		panic("ItemManagerMock.UpdateItemProcessedFunc: method is nil but ItemManager.UpdateItemProcessed was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		ItemID         int64
		Extraction     *domain.ExtractedContent
		Classification *domain.Classification
	}{
		Ctx:            ctx,
		ItemID:         itemID,
		Extraction:     extraction,
		Classification: classification,
	}
	mock.lockUpdateItemProcessed.Lock()
	mock.calls.UpdateItemProcessed = append(mock.calls.UpdateItemProcessed, callInfo)
	mock.lockUpdateItemProcessed.Unlock()
	return mock.UpdateItemProcessedFunc(ctx, itemID, extraction, classification)
}

// UpdateItemProcessedCalls gets all the calls that were made to UpdateItemProcessed.
// Check the length with:
//
//	len(mockedItemManager.UpdateItemProcessedCalls())
func (mock *ItemManagerMock) UpdateItemProcessedCalls() []struct {
	Ctx            context.Context
	ItemID         int64
	Extraction     *domain.ExtractedContent
	Classification *domain.Classification
} {
	var calls []struct {
		Ctx            context.Context
		ItemID         int64
		Extraction     *domain.ExtractedContent
		Classification *domain.Classification
	}
	mock.lockUpdateItemProcessed.RLock()
	calls = mock.calls.UpdateItemProcessed
	mock.lockUpdateItemProcessed.RUnlock()
	return calls
}
