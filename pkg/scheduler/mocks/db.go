// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"
	"time"

	"github.com/umputun/newscope/pkg/db"
)

// DatabaseMock is a mock implementation of scheduler.Database.
//
//	func TestSomethingThatUsesDatabase(t *testing.T) {
//
//		// make and configure a mocked scheduler.Database
//		mockedDatabase := &DatabaseMock{
//			CreateItemFunc: func(ctx context.Context, item *db.Item) error {
//				panic("mock out the CreateItem method")
//			},
//			GetFeedFunc: func(ctx context.Context, id int64) (*db.Feed, error) {
//				panic("mock out the GetFeed method")
//			},
//			GetFeedsFunc: func(ctx context.Context, enabledOnly bool) ([]db.Feed, error) {
//				panic("mock out the GetFeeds method")
//			},
//			GetFeedsToFetchFunc: func(ctx context.Context, limit int) ([]db.Feed, error) {
//				panic("mock out the GetFeedsToFetch method")
//			},
//			GetItemFunc: func(ctx context.Context, id int64) (*db.Item, error) {
//				panic("mock out the GetItem method")
//			},
//			GetItemsNeedingExtractionFunc: func(ctx context.Context, limit int) ([]db.Item, error) {
//				panic("mock out the GetItemsNeedingExtraction method")
//			},
//			GetRecentFeedbackFunc: func(ctx context.Context, feedbackType string, limit int) ([]db.FeedbackExample, error) {
//				panic("mock out the GetRecentFeedback method")
//			},
//			GetUnclassifiedItemsFunc: func(ctx context.Context, limit int) ([]db.Item, error) {
//				panic("mock out the GetUnclassifiedItems method")
//			},
//			ItemExistsFunc: func(ctx context.Context, feedID int64, guid string) (bool, error) {
//				panic("mock out the ItemExists method")
//			},
//			UpdateClassificationsFunc: func(ctx context.Context, classifications []db.Classification, itemsByGUID map[string]int64) error {
//				panic("mock out the UpdateClassifications method")
//			},
//			UpdateFeedErrorFunc: func(ctx context.Context, feedID int64, errMsg string) error {
//				panic("mock out the UpdateFeedError method")
//			},
//			UpdateFeedFetchedFunc: func(ctx context.Context, feedID int64, nextFetch time.Time) error {
//				panic("mock out the UpdateFeedFetched method")
//			},
//			UpdateItemExtractionFunc: func(ctx context.Context, itemID int64, content string, err error) error {
//				panic("mock out the UpdateItemExtraction method")
//			},
//		}
//
//		// use mockedDatabase in code that requires scheduler.Database
//		// and then make assertions.
//
//	}
type DatabaseMock struct {
	// CreateItemFunc mocks the CreateItem method.
	CreateItemFunc func(ctx context.Context, item *db.Item) error

	// GetFeedFunc mocks the GetFeed method.
	GetFeedFunc func(ctx context.Context, id int64) (*db.Feed, error)

	// GetFeedsFunc mocks the GetFeeds method.
	GetFeedsFunc func(ctx context.Context, enabledOnly bool) ([]db.Feed, error)

	// GetFeedsToFetchFunc mocks the GetFeedsToFetch method.
	GetFeedsToFetchFunc func(ctx context.Context, limit int) ([]db.Feed, error)

	// GetItemFunc mocks the GetItem method.
	GetItemFunc func(ctx context.Context, id int64) (*db.Item, error)

	// GetItemsNeedingExtractionFunc mocks the GetItemsNeedingExtraction method.
	GetItemsNeedingExtractionFunc func(ctx context.Context, limit int) ([]db.Item, error)

	// GetRecentFeedbackFunc mocks the GetRecentFeedback method.
	GetRecentFeedbackFunc func(ctx context.Context, feedbackType string, limit int) ([]db.FeedbackExample, error)

	// GetUnclassifiedItemsFunc mocks the GetUnclassifiedItems method.
	GetUnclassifiedItemsFunc func(ctx context.Context, limit int) ([]db.Item, error)

	// ItemExistsFunc mocks the ItemExists method.
	ItemExistsFunc func(ctx context.Context, feedID int64, guid string) (bool, error)

	// UpdateClassificationsFunc mocks the UpdateClassifications method.
	UpdateClassificationsFunc func(ctx context.Context, classifications []db.Classification, itemsByGUID map[string]int64) error

	// UpdateFeedErrorFunc mocks the UpdateFeedError method.
	UpdateFeedErrorFunc func(ctx context.Context, feedID int64, errMsg string) error

	// UpdateFeedFetchedFunc mocks the UpdateFeedFetched method.
	UpdateFeedFetchedFunc func(ctx context.Context, feedID int64, nextFetch time.Time) error

	// UpdateItemExtractionFunc mocks the UpdateItemExtraction method.
	UpdateItemExtractionFunc func(ctx context.Context, itemID int64, content string, err error) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateItem holds details about calls to the CreateItem method.
		CreateItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Item is the item argument value.
			Item *db.Item
		}
		// GetFeed holds details about calls to the GetFeed method.
		GetFeed []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// GetFeeds holds details about calls to the GetFeeds method.
		GetFeeds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EnabledOnly is the enabledOnly argument value.
			EnabledOnly bool
		}
		// GetFeedsToFetch holds details about calls to the GetFeedsToFetch method.
		GetFeedsToFetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int
		}
		// GetItem holds details about calls to the GetItem method.
		GetItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// GetItemsNeedingExtraction holds details about calls to the GetItemsNeedingExtraction method.
		GetItemsNeedingExtraction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int
		}
		// GetRecentFeedback holds details about calls to the GetRecentFeedback method.
		GetRecentFeedback []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FeedbackType is the feedbackType argument value.
			FeedbackType string
			// Limit is the limit argument value.
			Limit int
		}
		// GetUnclassifiedItems holds details about calls to the GetUnclassifiedItems method.
		GetUnclassifiedItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int
		}
		// ItemExists holds details about calls to the ItemExists method.
		ItemExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FeedID is the feedID argument value.
			FeedID int64
			// GUID is the guid argument value.
			GUID string
		}
		// UpdateClassifications holds details about calls to the UpdateClassifications method.
		UpdateClassifications []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Classifications is the classifications argument value.
			Classifications []db.Classification
			// ItemsByGUID is the itemsByGUID argument value.
			ItemsByGUID map[string]int64
		}
		// UpdateFeedError holds details about calls to the UpdateFeedError method.
		UpdateFeedError []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FeedID is the feedID argument value.
			FeedID int64
			// ErrMsg is the errMsg argument value.
			ErrMsg string
		}
		// UpdateFeedFetched holds details about calls to the UpdateFeedFetched method.
		UpdateFeedFetched []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FeedID is the feedID argument value.
			FeedID int64
			// NextFetch is the nextFetch argument value.
			NextFetch time.Time
		}
		// UpdateItemExtraction holds details about calls to the UpdateItemExtraction method.
		UpdateItemExtraction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ItemID is the itemID argument value.
			ItemID int64
			// Content is the content argument value.
			Content string
			// Err is the err argument value.
			Err error
		}
	}
	lockCreateItem                sync.RWMutex
	lockGetFeed                   sync.RWMutex
	lockGetFeeds                  sync.RWMutex
	lockGetFeedsToFetch           sync.RWMutex
	lockGetItem                   sync.RWMutex
	lockGetItemsNeedingExtraction sync.RWMutex
	lockGetRecentFeedback         sync.RWMutex
	lockGetUnclassifiedItems      sync.RWMutex
	lockItemExists                sync.RWMutex
	lockUpdateClassifications     sync.RWMutex
	lockUpdateFeedError           sync.RWMutex
	lockUpdateFeedFetched         sync.RWMutex
	lockUpdateItemExtraction      sync.RWMutex
}

// CreateItem calls CreateItemFunc.
func (mock *DatabaseMock) CreateItem(ctx context.Context, item *db.Item) error {
	if mock.CreateItemFunc == nil {
		panic("DatabaseMock.CreateItemFunc: method is nil but Database.CreateItem was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Item *db.Item
	}{
		Ctx:  ctx,
		Item: item,
	}
	mock.lockCreateItem.Lock()
	mock.calls.CreateItem = append(mock.calls.CreateItem, callInfo)
	mock.lockCreateItem.Unlock()
	return mock.CreateItemFunc(ctx, item)
}

// CreateItemCalls gets all the calls that were made to CreateItem.
// Check the length with:
//
//	len(mockedDatabase.CreateItemCalls())
func (mock *DatabaseMock) CreateItemCalls() []struct {
	Ctx  context.Context
	Item *db.Item
} {
	var calls []struct {
		Ctx  context.Context
		Item *db.Item
	}
	mock.lockCreateItem.RLock()
	calls = mock.calls.CreateItem
	mock.lockCreateItem.RUnlock()
	return calls
}

// GetFeed calls GetFeedFunc.
func (mock *DatabaseMock) GetFeed(ctx context.Context, id int64) (*db.Feed, error) {
	if mock.GetFeedFunc == nil {
		panic("DatabaseMock.GetFeedFunc: method is nil but Database.GetFeed was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetFeed.Lock()
	mock.calls.GetFeed = append(mock.calls.GetFeed, callInfo)
	mock.lockGetFeed.Unlock()
	return mock.GetFeedFunc(ctx, id)
}

// GetFeedCalls gets all the calls that were made to GetFeed.
// Check the length with:
//
//	len(mockedDatabase.GetFeedCalls())
func (mock *DatabaseMock) GetFeedCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockGetFeed.RLock()
	calls = mock.calls.GetFeed
	mock.lockGetFeed.RUnlock()
	return calls
}

// GetFeeds calls GetFeedsFunc.
func (mock *DatabaseMock) GetFeeds(ctx context.Context, enabledOnly bool) ([]db.Feed, error) {
	if mock.GetFeedsFunc == nil {
		panic("DatabaseMock.GetFeedsFunc: method is nil but Database.GetFeeds was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		EnabledOnly bool
	}{
		Ctx:         ctx,
		EnabledOnly: enabledOnly,
	}
	mock.lockGetFeeds.Lock()
	mock.calls.GetFeeds = append(mock.calls.GetFeeds, callInfo)
	mock.lockGetFeeds.Unlock()
	return mock.GetFeedsFunc(ctx, enabledOnly)
}

// GetFeedsCalls gets all the calls that were made to GetFeeds.
// Check the length with:
//
//	len(mockedDatabase.GetFeedsCalls())
func (mock *DatabaseMock) GetFeedsCalls() []struct {
	Ctx         context.Context
	EnabledOnly bool
} {
	var calls []struct {
		Ctx         context.Context
		EnabledOnly bool
	}
	mock.lockGetFeeds.RLock()
	calls = mock.calls.GetFeeds
	mock.lockGetFeeds.RUnlock()
	return calls
}

// GetFeedsToFetch calls GetFeedsToFetchFunc.
func (mock *DatabaseMock) GetFeedsToFetch(ctx context.Context, limit int) ([]db.Feed, error) {
	if mock.GetFeedsToFetchFunc == nil {
		panic("DatabaseMock.GetFeedsToFetchFunc: method is nil but Database.GetFeedsToFetch was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int
	}{
		Ctx:   ctx,
		Limit: limit,
	}
	mock.lockGetFeedsToFetch.Lock()
	mock.calls.GetFeedsToFetch = append(mock.calls.GetFeedsToFetch, callInfo)
	mock.lockGetFeedsToFetch.Unlock()
	return mock.GetFeedsToFetchFunc(ctx, limit)
}

// GetFeedsToFetchCalls gets all the calls that were made to GetFeedsToFetch.
// Check the length with:
//
//	len(mockedDatabase.GetFeedsToFetchCalls())
func (mock *DatabaseMock) GetFeedsToFetchCalls() []struct {
	Ctx   context.Context
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Limit int
	}
	mock.lockGetFeedsToFetch.RLock()
	calls = mock.calls.GetFeedsToFetch
	mock.lockGetFeedsToFetch.RUnlock()
	return calls
}

// GetItem calls GetItemFunc.
func (mock *DatabaseMock) GetItem(ctx context.Context, id int64) (*db.Item, error) {
	if mock.GetItemFunc == nil {
		panic("DatabaseMock.GetItemFunc: method is nil but Database.GetItem was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetItem.Lock()
	mock.calls.GetItem = append(mock.calls.GetItem, callInfo)
	mock.lockGetItem.Unlock()
	return mock.GetItemFunc(ctx, id)
}

// GetItemCalls gets all the calls that were made to GetItem.
// Check the length with:
//
//	len(mockedDatabase.GetItemCalls())
func (mock *DatabaseMock) GetItemCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockGetItem.RLock()
	calls = mock.calls.GetItem
	mock.lockGetItem.RUnlock()
	return calls
}

// GetItemsNeedingExtraction calls GetItemsNeedingExtractionFunc.
func (mock *DatabaseMock) GetItemsNeedingExtraction(ctx context.Context, limit int) ([]db.Item, error) {
	if mock.GetItemsNeedingExtractionFunc == nil {
		panic("DatabaseMock.GetItemsNeedingExtractionFunc: method is nil but Database.GetItemsNeedingExtraction was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int
	}{
		Ctx:   ctx,
		Limit: limit,
	}
	mock.lockGetItemsNeedingExtraction.Lock()
	mock.calls.GetItemsNeedingExtraction = append(mock.calls.GetItemsNeedingExtraction, callInfo)
	mock.lockGetItemsNeedingExtraction.Unlock()
	return mock.GetItemsNeedingExtractionFunc(ctx, limit)
}

// GetItemsNeedingExtractionCalls gets all the calls that were made to GetItemsNeedingExtraction.
// Check the length with:
//
//	len(mockedDatabase.GetItemsNeedingExtractionCalls())
func (mock *DatabaseMock) GetItemsNeedingExtractionCalls() []struct {
	Ctx   context.Context
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Limit int
	}
	mock.lockGetItemsNeedingExtraction.RLock()
	calls = mock.calls.GetItemsNeedingExtraction
	mock.lockGetItemsNeedingExtraction.RUnlock()
	return calls
}

// GetRecentFeedback calls GetRecentFeedbackFunc.
func (mock *DatabaseMock) GetRecentFeedback(ctx context.Context, feedbackType string, limit int) ([]db.FeedbackExample, error) {
	if mock.GetRecentFeedbackFunc == nil {
		panic("DatabaseMock.GetRecentFeedbackFunc: method is nil but Database.GetRecentFeedback was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		FeedbackType string
		Limit        int
	}{
		Ctx:          ctx,
		FeedbackType: feedbackType,
		Limit:        limit,
	}
	mock.lockGetRecentFeedback.Lock()
	mock.calls.GetRecentFeedback = append(mock.calls.GetRecentFeedback, callInfo)
	mock.lockGetRecentFeedback.Unlock()
	return mock.GetRecentFeedbackFunc(ctx, feedbackType, limit)
}

// GetRecentFeedbackCalls gets all the calls that were made to GetRecentFeedback.
// Check the length with:
//
//	len(mockedDatabase.GetRecentFeedbackCalls())
func (mock *DatabaseMock) GetRecentFeedbackCalls() []struct {
	Ctx          context.Context
	FeedbackType string
	Limit        int
} {
	var calls []struct {
		Ctx          context.Context
		FeedbackType string
		Limit        int
	}
	mock.lockGetRecentFeedback.RLock()
	calls = mock.calls.GetRecentFeedback
	mock.lockGetRecentFeedback.RUnlock()
	return calls
}

// GetUnclassifiedItems calls GetUnclassifiedItemsFunc.
func (mock *DatabaseMock) GetUnclassifiedItems(ctx context.Context, limit int) ([]db.Item, error) {
	if mock.GetUnclassifiedItemsFunc == nil {
		panic("DatabaseMock.GetUnclassifiedItemsFunc: method is nil but Database.GetUnclassifiedItems was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int
	}{
		Ctx:   ctx,
		Limit: limit,
	}
	mock.lockGetUnclassifiedItems.Lock()
	mock.calls.GetUnclassifiedItems = append(mock.calls.GetUnclassifiedItems, callInfo)
	mock.lockGetUnclassifiedItems.Unlock()
	return mock.GetUnclassifiedItemsFunc(ctx, limit)
}

// GetUnclassifiedItemsCalls gets all the calls that were made to GetUnclassifiedItems.
// Check the length with:
//
//	len(mockedDatabase.GetUnclassifiedItemsCalls())
func (mock *DatabaseMock) GetUnclassifiedItemsCalls() []struct {
	Ctx   context.Context
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Limit int
	}
	mock.lockGetUnclassifiedItems.RLock()
	calls = mock.calls.GetUnclassifiedItems
	mock.lockGetUnclassifiedItems.RUnlock()
	return calls
}

// ItemExists calls ItemExistsFunc.
func (mock *DatabaseMock) ItemExists(ctx context.Context, feedID int64, guid string) (bool, error) {
	if mock.ItemExistsFunc == nil {
		panic("DatabaseMock.ItemExistsFunc: method is nil but Database.ItemExists was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		FeedID int64
		GUID   string
	}{
		Ctx:    ctx,
		FeedID: feedID,
		GUID:   guid,
	}
	mock.lockItemExists.Lock()
	mock.calls.ItemExists = append(mock.calls.ItemExists, callInfo)
	mock.lockItemExists.Unlock()
	return mock.ItemExistsFunc(ctx, feedID, guid)
}

// ItemExistsCalls gets all the calls that were made to ItemExists.
// Check the length with:
//
//	len(mockedDatabase.ItemExistsCalls())
func (mock *DatabaseMock) ItemExistsCalls() []struct {
	Ctx    context.Context
	FeedID int64
	GUID   string
} {
	var calls []struct {
		Ctx    context.Context
		FeedID int64
		GUID   string
	}
	mock.lockItemExists.RLock()
	calls = mock.calls.ItemExists
	mock.lockItemExists.RUnlock()
	return calls
}

// UpdateClassifications calls UpdateClassificationsFunc.
func (mock *DatabaseMock) UpdateClassifications(ctx context.Context, classifications []db.Classification, itemsByGUID map[string]int64) error {
	if mock.UpdateClassificationsFunc == nil {
		panic("DatabaseMock.UpdateClassificationsFunc: method is nil but Database.UpdateClassifications was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Classifications []db.Classification
		ItemsByGUID     map[string]int64
	}{
		Ctx:             ctx,
		Classifications: classifications,
		ItemsByGUID:     itemsByGUID,
	}
	mock.lockUpdateClassifications.Lock()
	mock.calls.UpdateClassifications = append(mock.calls.UpdateClassifications, callInfo)
	mock.lockUpdateClassifications.Unlock()
	return mock.UpdateClassificationsFunc(ctx, classifications, itemsByGUID)
}

// UpdateClassificationsCalls gets all the calls that were made to UpdateClassifications.
// Check the length with:
//
//	len(mockedDatabase.UpdateClassificationsCalls())
func (mock *DatabaseMock) UpdateClassificationsCalls() []struct {
	Ctx             context.Context
	Classifications []db.Classification
	ItemsByGUID     map[string]int64
} {
	var calls []struct {
		Ctx             context.Context
		Classifications []db.Classification
		ItemsByGUID     map[string]int64
	}
	mock.lockUpdateClassifications.RLock()
	calls = mock.calls.UpdateClassifications
	mock.lockUpdateClassifications.RUnlock()
	return calls
}

// UpdateFeedError calls UpdateFeedErrorFunc.
func (mock *DatabaseMock) UpdateFeedError(ctx context.Context, feedID int64, errMsg string) error {
	if mock.UpdateFeedErrorFunc == nil {
		panic("DatabaseMock.UpdateFeedErrorFunc: method is nil but Database.UpdateFeedError was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		FeedID int64
		ErrMsg string
	}{
		Ctx:    ctx,
		FeedID: feedID,
		ErrMsg: errMsg,
	}
	mock.lockUpdateFeedError.Lock()
	mock.calls.UpdateFeedError = append(mock.calls.UpdateFeedError, callInfo)
	mock.lockUpdateFeedError.Unlock()
	return mock.UpdateFeedErrorFunc(ctx, feedID, errMsg)
}

// UpdateFeedErrorCalls gets all the calls that were made to UpdateFeedError.
// Check the length with:
//
//	len(mockedDatabase.UpdateFeedErrorCalls())
func (mock *DatabaseMock) UpdateFeedErrorCalls() []struct {
	Ctx    context.Context
	FeedID int64
	ErrMsg string
} {
	var calls []struct {
		Ctx    context.Context
		FeedID int64
		ErrMsg string
	}
	mock.lockUpdateFeedError.RLock()
	calls = mock.calls.UpdateFeedError
	mock.lockUpdateFeedError.RUnlock()
	return calls
}

// UpdateFeedFetched calls UpdateFeedFetchedFunc.
func (mock *DatabaseMock) UpdateFeedFetched(ctx context.Context, feedID int64, nextFetch time.Time) error {
	if mock.UpdateFeedFetchedFunc == nil {
		panic("DatabaseMock.UpdateFeedFetchedFunc: method is nil but Database.UpdateFeedFetched was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		FeedID    int64
		NextFetch time.Time
	}{
		Ctx:       ctx,
		FeedID:    feedID,
		NextFetch: nextFetch,
	}
	mock.lockUpdateFeedFetched.Lock()
	mock.calls.UpdateFeedFetched = append(mock.calls.UpdateFeedFetched, callInfo)
	mock.lockUpdateFeedFetched.Unlock()
	return mock.UpdateFeedFetchedFunc(ctx, feedID, nextFetch)
}

// UpdateFeedFetchedCalls gets all the calls that were made to UpdateFeedFetched.
// Check the length with:
//
//	len(mockedDatabase.UpdateFeedFetchedCalls())
func (mock *DatabaseMock) UpdateFeedFetchedCalls() []struct {
	Ctx       context.Context
	FeedID    int64
	NextFetch time.Time
} {
	var calls []struct {
		Ctx       context.Context
		FeedID    int64
		NextFetch time.Time
	}
	mock.lockUpdateFeedFetched.RLock()
	calls = mock.calls.UpdateFeedFetched
	mock.lockUpdateFeedFetched.RUnlock()
	return calls
}

// UpdateItemExtraction calls UpdateItemExtractionFunc.
func (mock *DatabaseMock) UpdateItemExtraction(ctx context.Context, itemID int64, content string, err error) error {
	if mock.UpdateItemExtractionFunc == nil {
		panic("DatabaseMock.UpdateItemExtractionFunc: method is nil but Database.UpdateItemExtraction was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ItemID  int64
		Content string
		Err     error
	}{
		Ctx:     ctx,
		ItemID:  itemID,
		Content: content,
		Err:     err,
	}
	mock.lockUpdateItemExtraction.Lock()
	mock.calls.UpdateItemExtraction = append(mock.calls.UpdateItemExtraction, callInfo)
	mock.lockUpdateItemExtraction.Unlock()
	return mock.UpdateItemExtractionFunc(ctx, itemID, content, err)
}

// UpdateItemExtractionCalls gets all the calls that were made to UpdateItemExtraction.
// Check the length with:
//
//	len(mockedDatabase.UpdateItemExtractionCalls())
func (mock *DatabaseMock) UpdateItemExtractionCalls() []struct {
	Ctx     context.Context
	ItemID  int64
	Content string
	Err     error
} {
	var calls []struct {
		Ctx     context.Context
		ItemID  int64
		Content string
		Err     error
	}
	mock.lockUpdateItemExtraction.RLock()
	calls = mock.calls.UpdateItemExtraction
	mock.lockUpdateItemExtraction.RUnlock()
	return calls
}
